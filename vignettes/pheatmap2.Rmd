<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Pretty and parallel heatmap}
-->

Pretty and parallel heatmap
===========================

**Author**: Zuguang Gu ( z.gu@dkfz.de )

**Data**: `r Sys.Date()`

--------------------------------------------------------

```{r, echo = FALSE, message = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    fig.align = "center")
options(markdown.HTML.stylesheet = "custom.css")
```

**pheatmap2** package is based on original **pheatmap** package.

First, generate a matrix:

```{r}
set.seed(123)
mat = rbind(matrix(rnorm(50, 1), 5, ),
	        matrix(rnorm(50, -1), 5))
colnames(mat) = paste0("c", 1:10)
rownames(mat) = paste0("r", 1:10)
```

plot the matrix with default setting:

```{r, message = FALSE}
library(pheatmap2)
pheatmap2(mat)
```

With some basic settings:

```{r}
pheatmap2(mat, cluster_rows = FALSE, cluster_cols = FALSE, 
    show_colnames = FALSE, show_rownames = FALSE, legend_title = NULL)
```

Map values to colors by a self-defined color function

```{r}
library(circlize)
pheatmap2(mat, col_fun = colorRamp2(c(-3, 0, 3), c("green", "white", "red")))
```

If `col_fun` is set, color mapping is resistant to outliers.

```{r, fig.width = 14, fig.height = 7, echo = c(1:2, 6, 9)}
mat2 = mat
mat2[1, 1] = 10
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow = 1, ncol = 2)))
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
pheatmap2(mat2, newpage = FALSE)
upViewport()
pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
pheatmap2(mat2, col_fun = colorRamp2(c(-3, 0, 3), c("green", "white", "red")), 
	newpage = FALSE)
upViewport(2)
```

Define column annotations and corresponding colors (same as **pheatmap** package)

```{r}
annotation = data.frame(label1 = sample(c("a", "b"), 10, replace = TRUE),
                        label2 = sample(c("c", "d"), 10, replace = TRUE),
						label3 = 1:10)
rownames(annotation) = colnames(mat)
annotation
pheatmap2(mat, annotation = annotation)
```

Set the annotation colors

```{r}
annotation_colors = list(label1 = c("a" = "red", "b" = "blue"),
	                     label2 = c("c" = "yellow", "d" = "green"))
annotation_colors
pheatmap2(mat, annotation = annotation, annotation_colors = annotation_colors)
```

generate an additional matrix

```{r}
mat2 = matrix(runif(40), 10, 4)
colnames(mat2) = paste0("d", 1:4)
```

plot the heatmap with the additional matrix. Arguments for the additional matrix
are similar as the main matrix, but should be put into a list. E.g., `col_fun` is
for the main matrix, then `col_fun_list` is for the additional matrix. 

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat, 
	legend_title = "mat", 

	mat_list = list(mat2 = mat2),
	col_fun_list = list(mat2 = colorRamp2(c(0, 0.5, 1), c("green", "white", "red"))),
	legend_title_list = "mat2")
```

Set title/sub titles

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat, 
	legend_title = "mat", 
	main = "two heatmap", sub_main = c("mat1", "mat2"),

	mat_list = list(mat2 = mat2),
	col_fun_list = list(mat2 = colorRamp2(c(0, 0.5, 1), c("green", "white", "red"))),
	legend_title_list = "mat2")
```

Set gaps between heatmap and the title/sub titles. Since **pheatmap2** is modified
from *pheatmap*, actually, all heatmap are stored in one big matrix and keep several
columns empty to simulate gaps between heatmap. Thus here gap is the number of empty
columns between two heatmap.

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat, 
	legend_title = "mat", 
	gap = 3,

	mat_list = list(mat2 = mat2),
	col_fun_list = list(mat2 = colorRamp2(c(0, 0.5, 1), c("green", "white", "red"))),
	legend_title_list = "mat2")
```

Annotations for the additional matrix. If annotation is same for two heatmap,
e.g., the first heatmap and the second both have `label1` annotation, the legend
for this annotation is only drawn once.

```{r}
annotation2 = data.frame(label1 = c("a", "a", "b", "b"), label5 = 1:4)
rownames(annotation2) = colnames(mat2)
annotation_colors2 = list(label1 = c("a" = "red", "b" = "blue"))
```

The complex heatmap

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat,
	legend_title = "mat", 
	annotation = annotation, 
	annotation_colors = annotation_colors,
	
	mat_list = list(mat2 = mat2),
	col_fun_list = list(mat2 = colorRamp2(c(0, 0.5, 1), c("green", "white", "red"))),
	legend_title_list = "mat2",
	annotation_list = list("mat2" = annotation2),
	annotation_colors_list = list("mat2" = annotation_colors2))
```						 

matrix can also be character. This is a way to simulate column annotation.
Internally, characters will be firstly converted to factors, then replaced 
as integer numbers and mapping each level of factor to a color.

```{r}
group = ifelse(rowMeans(mat) > 0, "high", "low")
gender = sample(c("male", "female"), nrow(mat), replace = TRUE)
```

Still, you need to use `colorRamp2` to assign colors for each level (levels are
represented by integers)

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat, 
	legend_title = "mat", 

	mat_list = list(group = group, gender = gender),	
	col_fun_list = list(group = colorRamp2(1:2, c("red", "blue")),
		                gender = colorRamp2(1:2, c("orange", "pink"))),
	legend_title_list = c("group", "gender"),
	gap = c(1, 0))
```

Finally, let's make a heatmap which contains everything.

```{r fig.width = 10, fig.height = 7}
pheatmap2(mat, 
	legend_title = "mat", 
	annotation = annotation, 
	annotation_colors = annotation_colors,
	
	mat_list = list(group = group, mat2 = mat2),
	col_fun_list = list(group = colorRamp2(1:2, c("red", "blue")),
                        mat2 = colorRamp2(c(0, 0.5, 1), c("green", "white", "red"))),
	legend_title_list = c("group", "mat2"),
	annotation_list = list("mat2" = annotation2),
	annotation_colors_list = list("mat2" = annotation_colors2))
```	
